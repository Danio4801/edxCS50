{\rtf1\ansi\ansicpg1252\cocoartf2709
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;\f1\fnil\fcharset0 AppleColorEmoji;\f2\fswiss\fcharset0 Helvetica;
}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww28600\viewh18000\viewkind0
\deftab560
\pard\pardeftab560\slleading20\partightenfactor0

\f0\fs32 \cf0 	4 Steps of the process called \'93compiling\'94 :\
\
	Step 1 - preprocessing the file - program is preprocessed without your knowledge (by the clang, in this case) \
Preprocessing:\
#include <cs50.h>\
#include<stdio.h>\
Preprocessor directive - anything with the \'93#\'94 symbol should be (and is) analysed initially before anything else happens (by clang in this lecture) \
/usr/include - folder that contains all of # files, clang basically copy all of the commands from this folder, if the #file is included for example #include <cs50.h> -> clang will look for the cs50 file in the /usr/include \
\
	Step 2 - compiling \
Compiling:\
Your code in for example C is translated to Assembly language, language located closer to computer logic (still not zeros and ones)\
\
	Step 3 - assembling  \
Assembling\
In this step code is converted to machine code ( 0 and 1 )\
\
	Step 4 - linking \
Combining (linking) code withe the libraries (like cs50.c ) and more. So basically it\'92s linking and combining all of the zeros and ones coming from the different places. \
\
Decompiling - reversing the process \
\
	Bug\
Bug - mistake, error in code.\
Bug - history of name - Harvard computer  could not work properly because of the bug, the actual bug was discovered inside the computer.\
Debugger - software that help us debug the code. \
\
	How to use debugger
\f1 \uc0\u10067 
\f0  \
First of all, we have to add breaking point and then write in the terminal debug50 ./filename . For example debug50 ./buggy0\
\
	Typecasting \
(a + b) / (float) 3; typecasting, we are converting the thing after the () to the data type (if possible)   \
\
	Array \
Array is the way of storing the data  back to back to back in the computer memory in the way that we can access to that easily  \
example:\
int scores[3];// this is how to declare the array of ints called scores. The array can store up to 3 independent data of int.\
score[0] = 72; // here\'92s how to store some data in the array (index 0)(index0 is the first number, we start at 0)  \
\
\
\
\
Plaintext -> |algrithm| -> output (encrypted) text \
Key - the secret number that only we and the other person know, combined with the algorithm let us read the message (encrypt /decrypt  the message).\
\
	Command line arguments \
int main( int argc, string argv[]) - main will take arguments \
argc - argument count  (arrays don\'92t keep track of their own length) \
argv - array of the words \
How to use this\uc0\u10067  \
Example 1: \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f2\fs24 \cf0 4 int main(int arg, string argv[])\
5 \{\
6 	printf("hello, %s\\n\'94, argv [1]);\
7 \}\
TERMINAL\
$ make greet \
$ ./greet David\
hello, David\

\fs32 So the output is hello David because argv[1] David (and argv[0] is ./greet btw)\

\f0 \
\pard\pardeftab560\slleading20\partightenfactor0
\cf0 echo $? In terminal tell us what int main() returned \
0 by default means success \
}